<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
    </style>
</head>
<body>
    <canvas id="canvas" style="display: block;">Canvas is not supported :(</canvas>

<script>
    class MyCanvas {
        constructor(root) {
            this.canv = document.querySelector(root),
            this.ctx = this.canv.getContext('2d');
            this.maxW = window.innerWidth;
            this.maxH = window.innerHeight;
        }

        setCanvasSize(){
            this.canv.width = this.maxW
            this.canv.height = this.maxH
        }
        
        getCanvas() {
            return this.ctx
        }

        getCanvasSize() {
            return {w: this.maxW, h:this.maxH}
        }
    }

    canv = new MyCanvas("#canvas")
    canv.setCanvasSize()
    let ctx = canv.getCanvas(),
    ctxSize = canv.getCanvasSize()

    
    
    
    const linesNum = Math.floor((Math.random() * 15-7)) + 7

    class CurvePlus {
        constructor(ctx) {
            this.ctx = ctx
        }

        generateDotArea(x, y, size, ratio, i) {
            // console.log(x,y)
            let
            dx = ((Math.random() * 1 - 0.3) + 0.3) * ratio,
            dy = ((Math.random() * 1 - 0.3) + 0.3) * ratio,
            boxCoord = {"top": y - (dy/2), "bottom": y + dy, "left": x - dx, "right": x + dx}
            if (boxCoord.top < 0) {
                boxCoord.top = 0
            }
            if (boxCoord.bottom > size.h) {
                boxCoord.bottom = size.h
            }
            if (boxCoord.left < 0 ) {
                boxCoord.left = 0
            }
            if (boxCoord.right > size.w) {
                boxCoord.right = size.w
            }


            if (i == 0) {
                boxCoord.top = size.h * (Math.random() * (0.2 - 0.1)) + 0.1
            }
            
            console.log(i, dx, dy, ratio, boxCoord)
            return boxCoord;

        }

        generateLinePath(size) {
            let
            curves = Math.floor((Math.random() * 4)) + 1,
            xs = [Math.floor((Math.random() * size.w))], 
            ys = [0],
            ratio = size.w / curves,
            x = xs[0],
            y = ys[0]

            ctx.beginPath();
            ctx.moveTo(x,y);
            for(let i = 0; i < curves; i++) {

                let area = this.generateDotArea(x, y, size, ratio, i);
                x = area.left + (Math.random() * (area.right - area.left))
                y = area.top + (Math.random() * (area.bottom - area.top))
                ctx.lineTo(x, y);
                xs.push(x)
                ys.push(y)
                console.log(x, y, curves)
            }
            ctx.stroke();
        }
    }
    ctx.fillStyle = '#c15151';
    ctx.lineWidth = 3
    // ctx.beginPath();
    // ctx.moveTo(50,0);
    // ctx.lineTo(600, 100);
    // ctx.stroke();

    let curve = new CurvePlus(ctx)
    curve.generateLinePath(ctxSize)

    function generateLinePath(size) {
        let angleBorders = [180+20, 0-20],
        curves = Math.floor((Math.random() * 4)) + 1
        console.log(curves)

        let distanceSin, 
        distanceCos,
        distanceF,
        x = Math.floor((Math.random() * size.w)), 
        y = 0
        
        console.log()
        ctx.beginPath();
        ctx.moveTo(x,y);
        console.log(x)
        for(let i = 0; i < curves; i++) {
            // unique angle for start and for end
            if (i == 0 || i == curves - 1) {
                var newAngleBorders = [150, 30]
            }

            // calculate random angle
            let angle = Math.floor(Math.random() * (newAngleBorders[0] - newAngleBorders[1])) + newAngleBorders[1]
            // if angle is negative, e.g. -18 -> 342
            angle = angle < 0 ? angle + 360 : angle
            // return normal angle border
            newAngleBorders = angleBorders
            
            // calculate distance from x to border of canvas
            if (angle > 0 && angle <= 180) {
                distanceSin = size.h / Math.sin((angle * Math.PI) / 180 )
                distanceCos = angle >= 90 ? size.w - x : x
                distanceCos /= Math.abs(Math.cos(angle))
                
                distanceF = distanceSin / curves - i
                if (distanceCos < distanceSin && distanceF > distanceCos ) {
                    distanceF = distanceCos
                }

                x = angle >= 90 ? Math.cos((180 - angle) * Math.PI / 180) : Math.cos(angle * Math.PI / 180)
                x = distanceF / x
                y = angle >= 90 ? Math.sin((180 - angle) * Math.PI / 180) : Math.sin(angle * Math.PI / 180)
                y = distanceF / y
                
            }else {
                
            }
            ctx.lineTo(x, y);
            console.log(angle, x + "x", y +" y", distanceSin, distanceCos, distanceF)
        }
        ctx.stroke();
    }
    generateLinePath(ctxSize)

    // ctx.globalCompositeOperation='destination-over';
    // ctx.globalCompositeOperation='source-over';

    ctx.beginPath();
    ctx.arc(0, 200, 100, 0, Math.PI * 2)
    ctx.fill()

    
    

</script>
</body>
</html>